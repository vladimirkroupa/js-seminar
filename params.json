{"name":"Js-seminar","tagline":"","body":"# Functions\r\n\r\n## Function literal\r\n* [function literal](https://jsbin.com/keyujeq/7/edit?js,console,output)\r\n\r\n## Function is an object\r\n* [function is an object](https://jsbin.com/vuzome/7/edit?js,console,output)\r\n\r\n## Function scope\r\nThere is no block scope in JS, but there is function scope.\r\n\r\n* [no block scope](https://jsbin.com/jayiqa/2/edit?js,console,output)\r\n\r\n* [function scope](https://jsbin.com/fosugi/1/edit?js,console,output)\r\n\r\n## Recursion\r\nThere is no tail call optimization -> limit on depth of recursion.\r\n\r\n* [no tail call optimization](https://jsbin.com/zukowo/1/edit?js,console,output)\r\n\r\n## Arguments\r\nFunction receives extra `arguments` parameter.\r\n\r\n* [arguments object](https://jsbin.com/kivape/4/edit?js,console,output)\r\n\r\n* [arguments object length](https://jsbin.com/lutewa/2/edit?js,console,output)\r\n\r\n* [arguments object no array methods](https://jsbin.com/kuwema/1/edit?js,console,output)\r\n\r\n## Invocation\r\n\r\n> Apart from `arguments` parameter, function receives `this` parameter. Value of `this` is determined by *invocation pattern*.\r\n\r\n### 1. Method Invocation Pattern\r\n\r\n    var a = { fun : console.log };\r\n    a.fun('a');\r\n\r\n> Function stored as property of an object is a *method*. \r\n\r\n> When a method is invoked, `this` is bound to that object.\r\n\r\n* [method invocation](https://jsbin.com/zuniye/1/edit?js,console,output)\r\n\r\n### 2. Function Invocation Pattern\r\n\r\n> When function is not a property of an object, it is invoked as a function.\r\n\r\n    var sum = add(3, 4);\r\n\r\n> When function is invoked with this pattern, `this` is bound to the global object.\r\n> A consequence of this is that a method cannot employ an inner function to help it.\r\n\r\n* [inner function and this](https://jsbin.com/wapini/1/edit?js,console,output)\r\n* [workaround](https://jsbin.com/jimuxa/1/edit?js,console,output)\r\n\r\n### 3. Constructor Invocation Pattern\r\n> If a function is invoked with the `new` prefix, then a new object will be created with a hidden link to the value of the function's `prototype` member, and `this` will be bound to that new object.\r\n\r\n    var air = new Air(encyInstance, jq);\r\n    air.initAirTab();\r\n    air.initSearchTab();\r\n\r\n> The `new` prefix also changes the behavior of the `return` statement.\r\n> If the function was invoked with the `new` prefix and the `return` value is not an object, then `this` (the new object) is returned instead.\r\n\r\n    function Air(encyInstance, jQuery) {\r\n        this.airService = new AirService(encyInstance);\r\n        this.dialogFactory = new DialogFactory(window, this.airService, encyInstance, jQuery);        \r\n        // there is no return statement\r\n    }\r\n\r\n> Functions that are intended to be used with the `new` prefix are called *constructors*. By convention, the should be capitalized.\r\n> If a constructor is called without the `new` prefix, bad things happen.\r\n\r\n### 4. Apply Invocation Pattern\r\n\r\n> The apply method lets us construct an array of arguments to use to invoke a function.\r\nIt also lets us choose the value of this. The apply method takes two parameters.\r\nThe first is the value that should be bound to this. The second is an array of\r\nparameters.\r\n\r\n[using apply to supply arguments](https://jsbin.com/xehuhomane/1/edit?js,console,output)\r\n\r\n[using apply to supply arguments badly](https://jsbin.com/zixirasate/1/edit?js,console,output)\r\n\r\n\r\n## Closure\r\nThe closure of the generated functions contain pointers to variables, not a snapshot of the values at the point of definition, meaning that if variables change, these changes are visible from within the function.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}